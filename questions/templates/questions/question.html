<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interview</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/alpinejs@3.x.x/dist/cdn.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap');
        @keyframes pulse-recording {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        .recording-pulse {
            animation: pulse-recording 1.5s ease-in-out infinite;
        }
        .scrollbar-thin::-webkit-scrollbar { width: 6px; }
        .scrollbar-thin::-webkit-scrollbar-track { background: transparent; }
        .scrollbar-thin::-webkit-scrollbar-thumb { background: #d1d5db; border-radius: 3px; }
        .scrollbar-thin::-webkit-scrollbar-thumb:hover { background: #9ca3af; }
    </style>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: { dark: '#1A1A1A' },
                    fontFamily: { sans: ['Inter', 'system-ui', 'sans-serif'] }
                }
            }
        }
    </script>
</head>
<body class="bg-white min-h-screen font-sans">
    {% include "includes/header.html" %}

    <div class="flex items-center justify-center p-6" style="min-height: calc(100vh - 65px);">

<div class="w-full max-w-xl" x-data="interviewApp()" x-init="init()">
    <!-- Loading state -->
    <div x-show="loading" class="text-center text-gray-400">
        Loading interviews...
    </div>

    <!-- Interviews (Standard Mode) -->
    <template x-if="!loading && !done && !chatMode">
        <div>
            <div class="flex justify-between items-center mb-4">
                <div class="text-sm text-gray-400">
                    Interview <span x-text="currentIndex + 1"></span> of <span x-text="interviews.length"></span>
                </div>
                <div class="flex gap-2">
                    <button
                        type="button"
                        @click="enterChatMode()"
                        class="flex items-center gap-2 px-3 py-1.5 rounded-full border text-sm transition-colors border-gray-300 text-gray-600 hover:border-teal-500 hover:text-teal-600"
                    >
                        <svg xmlns="http://www.w3.org/2000/svg" class="w-4 h-4" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                            <path stroke-linecap="round" stroke-linejoin="round" d="M8 12h.01M12 12h.01M16 12h.01M21 12c0 4.418-4.03 8-9 8a9.863 9.863 0 01-4.255-.949L3 20l1.395-3.72C3.512 15.042 3 13.574 3 12c0-4.418 4.03-8 9-8s9 3.582 9 8z" />
                        </svg>
                        <span>Chat Mode</span>
                    </button>
                    <button
                        type="button"
                        @click="toggleVoiceMode()"
                        :class="voiceMode ? 'bg-red-500 text-white border-red-500 recording-pulse' : 'border-gray-300 text-gray-600 hover:border-teal-500 hover:text-teal-600'"
                        class="flex items-center gap-2 px-3 py-1.5 rounded-full border text-sm transition-colors"
                    >
                        <svg xmlns="http://www.w3.org/2000/svg" class="w-4 h-4" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                            <path stroke-linecap="round" stroke-linejoin="round" d="M19 11a7 7 0 01-7 7m0 0a7 7 0 01-7-7m7 7v4m0 0H8m4 0h4m-4-8a3 3 0 01-3-3V5a3 3 0 116 0v6a3 3 0 01-3 3z" />
                        </svg>
                        <span x-text="voiceMode ? 'Listening...' : 'Voice Mode'"></span>
                    </button>
                </div>
            </div>

            <h1 class="text-2xl font-semibold text-dark leading-snug mb-8" x-text="interviews[currentIndex]?.text"></h1>

            <div>
                <textarea
                    x-model="answer"
                    x-ref="textarea"
                    class="w-full h-36 p-4 bg-gray-50 border border-gray-200 rounded-lg resize-none focus:outline-none focus:ring-2 focus:ring-teal-500 focus:border-transparent text-base"
                ></textarea>
                <div class="mt-6 flex justify-end">
                    <button
                        type="button"
                        @click="nextQuestion()"
                        :disabled="!answer.trim() || submitting"
                        class="bg-white text-gray-900 border-2 border-gray-900 w-12 h-12 flex items-center justify-center hover:bg-gray-900 hover:text-white transition-colors disabled:opacity-50 disabled:cursor-not-allowed"
                    >
                        <svg xmlns="http://www.w3.org/2000/svg" class="w-5 h-5" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                            <path stroke-linecap="round" stroke-linejoin="round" d="M9 5l7 7-7 7" />
                        </svg>
                    </button>
                </div>
            </div>
        </div>
    </template>

    <!-- Chat Mode -->
    <template x-if="!loading && chatMode">
        <div class="flex flex-col" style="height: calc(100vh - 150px);">
            <!-- Header with exit button -->
            <div class="flex justify-between items-center mb-4 flex-shrink-0">
                <div class="text-sm text-gray-400">
                    Chat Mode
                </div>
                <button
                    type="button"
                    @click="exitChatMode()"
                    class="flex items-center gap-2 px-3 py-1.5 rounded-full border text-sm transition-colors border-gray-300 text-gray-600 hover:border-red-500 hover:text-red-600"
                >
                    <svg xmlns="http://www.w3.org/2000/svg" class="w-4 h-4" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                        <path stroke-linecap="round" stroke-linejoin="round" d="M6 18L18 6M6 6l12 12" />
                    </svg>
                    <span>Exit Chat</span>
                </button>
            </div>

            <!-- Chat Messages -->
            <div class="flex-1 overflow-y-auto space-y-4 scrollbar-thin pr-2" x-ref="chatMessages">
                <template x-for="(msg, idx) in chatMessages" :key="idx">
                    <div :class="msg.role === 'user' ? 'flex justify-end' : 'flex justify-start'">
                        <div
                            :class="msg.role === 'user' ? 'bg-gray-900 text-white' : 'bg-gray-100 text-gray-900'"
                            class="max-w-[80%] px-4 py-3 rounded-lg text-sm whitespace-pre-wrap"
                            x-text="msg.content"
                        ></div>
                    </div>
                </template>
                <!-- Typing indicator -->
                <div x-show="chatTyping" class="flex justify-start">
                    <div class="bg-gray-100 text-gray-900 px-4 py-3 rounded-lg text-sm">
                        <div class="flex gap-1">
                            <span class="w-2 h-2 bg-gray-400 rounded-full animate-bounce" style="animation-delay: 0ms;"></span>
                            <span class="w-2 h-2 bg-gray-400 rounded-full animate-bounce" style="animation-delay: 150ms;"></span>
                            <span class="w-2 h-2 bg-gray-400 rounded-full animate-bounce" style="animation-delay: 300ms;"></span>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Chat Input -->
            <div class="flex-shrink-0 pt-4">
                <form @submit.prevent="sendChatAnswer()" class="relative">
                    <input
                        type="text"
                        x-model="chatInput"
                        x-ref="chatInput"
                        :disabled="chatFinished"
                        placeholder="Type your answer..."
                        class="w-full px-4 py-3 pr-12 bg-gray-50 border border-gray-200 rounded-full focus:outline-none focus:ring-2 focus:ring-teal-500 focus:border-transparent text-sm disabled:opacity-50 disabled:cursor-not-allowed"
                    >
                    <button
                        type="submit"
                        :disabled="!chatInput.trim() || submitting || chatFinished"
                        class="absolute right-2 top-1/2 -translate-y-1/2 w-8 h-8 flex items-center justify-center bg-gray-900 text-white rounded-full hover:bg-gray-700 transition-colors disabled:opacity-50 disabled:cursor-not-allowed"
                    >
                        <svg xmlns="http://www.w3.org/2000/svg" class="w-4 h-4" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                            <path stroke-linecap="round" stroke-linejoin="round" d="M14 5l7 7m0 0l-7 7m7-7H3" />
                        </svg>
                    </button>
                </form>
            </div>
        </div>
    </template>

    <!-- Done state -->
    <template x-if="done">
        <div>
            <h1 class="text-2xl font-semibold text-dark mb-2">Thank you</h1>
            <p class="text-gray-500 mb-6">Your answers have been recorded.</p>
            <a href="/" class="text-teal-600 hover:text-teal-700 hover:underline font-medium">Start again</a>
        </div>
    </template>
</div>

<script>
const CSRF_TOKEN = '{{ csrf_token }}';

function interviewApp() {
    return {
        loading: true,
        interviews: [],
        currentIndex: 0,
        answer: '',
        done: false,
        submitting: false,

        // Chat mode
        chatMode: false,
        chatMessages: [],
        chatInput: '',
        chatFinished: false,
        chatTyping: false,

        // Voice mode
        voiceMode: false,
        mediaStream: null,
        audioContext: null,
        workletNode: null,
        websocket: null,
        ttsAudio: null,
        workletURL: null,

        async init() {
            const response = await fetch('/api/interviews/');
            const data = await response.json();
            this.interviews = data.interviews;
            this.loading = false;
        },

        async toggleVoiceMode() {
            if (!this.voiceMode) {
                await this.startVoiceMode();
            } else {
                this.stopVoiceMode();
            }
        },

        async startVoiceMode() {
            try {
                // Get mic permission
                this.mediaStream = await navigator.mediaDevices.getUserMedia({
                    audio: { sampleRate: 24000, channelCount: 1, echoCancellation: true, noiseSuppression: true }
                });

                this.workletURL = this.createWorkletURL();
                this.voiceMode = true;

                // Play first interview and start listening
                await this.playCurrentInterview();
                await this.startListening();

            } catch (error) {
                console.error('Voice mode error:', error);
                alert('Failed to start voice mode: ' + error.message);
                this.stopVoiceMode();
            }
        },

        async playCurrentInterview() {
            if (!this.voiceMode) return;

            const interviewId = this.interviews[this.currentIndex].id;
            this.ttsAudio = new Audio(`/api/tts/${interviewId}/`);

            await new Promise(resolve => {
                this.ttsAudio.onended = resolve;
                this.ttsAudio.onerror = resolve;
                this.ttsAudio.play().catch(resolve);
            });
        },

        async startListening() {
            if (!this.voiceMode) return;

            // Get session token
            const tokenResponse = await fetch('/api/realtime-session/');
            const tokenData = await tokenResponse.json();
            if (!tokenResponse.ok) throw new Error(tokenData.error);

            const ephemeralKey = tokenData.client_secret.value;
            const self = this;

            // Connect WebSocket
            await new Promise((resolve, reject) => {
                self.websocket = new WebSocket(
                    'wss://api.openai.com/v1/realtime?model=gpt-4o-realtime-preview-2024-12-17',
                    ['realtime', `openai-insecure-api-key.${ephemeralKey}`, 'openai-beta.realtime-v1']
                );

                self.websocket.onopen = () => {
                    self.websocket.send(JSON.stringify({
                        type: 'session.update',
                        session: {
                            modalities: ['text', 'audio'],
                            input_audio_transcription: { model: 'whisper-1' },
                            turn_detection: {
                                type: 'server_vad',
                                threshold: 0.5,
                                prefix_padding_ms: 300,
                                silence_duration_ms: 500
                            }
                        }
                    }));
                    resolve();
                };

                self.websocket.onmessage = (event) => {
                    const msg = JSON.parse(event.data);
                    if (msg.type === 'conversation.item.input_audio_transcription.completed' && msg.transcript) {
                        self.answer = (self.answer + ' ' + msg.transcript).trim();
                    }
                };

                self.websocket.onerror = reject;
            });

            // Start audio capture
            this.audioContext = new AudioContext({ sampleRate: 24000 });
            const source = this.audioContext.createMediaStreamSource(this.mediaStream);

            await this.audioContext.audioWorklet.addModule(this.workletURL);
            this.workletNode = new AudioWorkletNode(this.audioContext, 'audio-processor');

            this.workletNode.port.onmessage = (event) => {
                if (self.websocket?.readyState === WebSocket.OPEN) {
                    self.websocket.send(JSON.stringify({
                        type: 'input_audio_buffer.append',
                        audio: self.arrayBufferToBase64(event.data)
                    }));
                }
            };

            source.connect(this.workletNode);
            this.workletNode.connect(this.audioContext.destination);
        },

        stopListening() {
            if (this.workletNode) {
                this.workletNode.disconnect();
                this.workletNode = null;
            }
            if (this.audioContext) {
                this.audioContext.close();
                this.audioContext = null;
            }
            if (this.websocket) {
                this.websocket.send(JSON.stringify({ type: 'input_audio_buffer.commit' }));
                this.websocket.close();
                this.websocket = null;
            }
        },

        async nextQuestion() {
            if (this.submitting || !this.answer.trim()) return;
            this.submitting = true;

            // Stop listening while transitioning
            if (this.voiceMode) {
                this.stopListening();
            }

            // Submit current answer
            await this.submitAnswer();

            // Move to next or finish
            if (this.currentIndex < this.interviews.length - 1) {
                this.currentIndex++;
                this.answer = '';

                if (this.voiceMode) {
                    // Play next interview and resume listening
                    await this.playCurrentInterview();
                    await this.startListening();
                } else {
                    this.$nextTick(() => this.$refs.textarea?.focus());
                }
            } else {
                this.stopVoiceMode();
                this.done = true;
            }

            this.submitting = false;
        },

        async submitAnswer() {
            const interviewId = this.interviews[this.currentIndex]?.id;
            if (!interviewId || !this.answer.trim()) return;

            await fetch('/api/submit-answer/', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json', 'X-CSRFToken': CSRF_TOKEN },
                body: JSON.stringify({ interview_id: interviewId, answer: this.answer.trim() })
            });
        },

        // Chat mode functions
        enterChatMode() {
            this.chatMode = true;
            this.chatFinished = false;
            this.currentIndex = 0;
            this.answer = '';
            this.chatMessages = [
                { role: 'assistant', content: "Hi! I'd like to ask you a few questions." },
                { role: 'assistant', content: this.interviews[0]?.text }
            ];
            this.$nextTick(() => {
                this.$refs.chatInput?.focus();
                this.scrollChatToBottom();
            });
        },

        exitChatMode() {
            this.chatMode = false;
            this.chatMessages = [];
            this.chatInput = '';
            this.chatFinished = false;
        },

        async sendChatAnswer() {
            if (!this.chatInput.trim() || this.submitting || this.chatFinished) return;

            const userAnswer = this.chatInput.trim();
            this.chatInput = '';

            // Add user message
            this.chatMessages.push({ role: 'user', content: userAnswer });
            this.scrollChatToBottom();

            // Submit answer to API
            this.answer = userAnswer;
            this.submitting = true;
            await this.submitAnswer();
            this.submitting = false;

            // Show typing indicator
            this.chatTyping = true;
            this.scrollChatToBottom();

            // Wait before showing next message
            await new Promise(resolve => setTimeout(resolve, 600));

            this.chatTyping = false;

            // Move to next interview or finish
            if (this.currentIndex < this.interviews.length - 1) {
                this.currentIndex++;
                this.answer = '';
                this.chatMessages.push({
                    role: 'assistant',
                    content: this.interviews[this.currentIndex].text
                });
                this.scrollChatToBottom();
                this.$nextTick(() => this.$refs.chatInput?.focus());
            } else {
                this.chatMessages.push({
                    role: 'assistant',
                    content: 'Thank you! Your answers have been recorded.'
                });
                this.chatFinished = true;
                this.scrollChatToBottom();
            }
        },

        scrollChatToBottom() {
            this.$nextTick(() => {
                const container = this.$refs.chatMessages;
                if (container) container.scrollTop = container.scrollHeight;
            });
        },

        stopVoiceMode() {
            this.voiceMode = false;

            if (this.ttsAudio) {
                this.ttsAudio.pause();
                this.ttsAudio = null;
            }

            this.stopListening();

            if (this.mediaStream) {
                this.mediaStream.getTracks().forEach(t => t.stop());
                this.mediaStream = null;
            }
        },

        arrayBufferToBase64(buffer) {
            let binary = '';
            const bytes = new Uint8Array(buffer);
            for (let i = 0; i < bytes.byteLength; i++) binary += String.fromCharCode(bytes[i]);
            return btoa(binary);
        },

        createWorkletURL() {
            const code = `
                class AudioProcessor extends AudioWorkletProcessor {
                    constructor() { super(); this.buffer = new Int16Array(2400); this.idx = 0; }
                    process(inputs) {
                        const input = inputs[0];
                        if (input.length > 0) {
                            const samples = input[0];
                            for (let i = 0; i < samples.length; i++) {
                                const s = Math.max(-1, Math.min(1, samples[i]));
                                this.buffer[this.idx++] = s < 0 ? s * 0x8000 : s * 0x7FFF;
                                if (this.idx >= 2400) { this.port.postMessage(this.buffer.buffer.slice(0)); this.idx = 0; }
                            }
                        }
                        return true;
                    }
                }
                registerProcessor('audio-processor', AudioProcessor);
            `;
            return URL.createObjectURL(new Blob([code], { type: 'application/javascript' }));
        }
    };
}
</script>

    </div>
</body>
</html>
